<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
</head>

<body>

	<div>
		<h1>Выучи ReactJS, устройся на работу. Введение 01</h1>
		<img src="../assets/les01/les0101.png" width="720" height="480" />
		<ul>
			<li>
				ReactJS: нужно уверенно владеть почти всем API React. Мы должны быть мастерами React. Около 10%
				возможностей (для метафреймворков и сложных библиотек) достаточно знать на уровне «слышал».
			</li>
			<li>JS: требуется глубокое знание языка: замыкания, классы, промисы и другие ключевые механизмы;</li>
			<li>>HTML/CSS: на том же уровне. При хорошем знании React и JS верстку можно быстро подтянуть по мере
				необходимости;</li>
			<li>TS: практическое использование типизации для выявления ошибок на этапе разработки и строгого контроля
				передачи
				данных между слоями и функциями. Особенно важно для утилитного и масштабируемого ПО, где строгая
				типизация
				помогает поддерживать стабильность и предсказуемость кода;</li>
			<li>Architecture: уже не только структура папок. Важно закладывать архитектурный фундамент проекта.
				Понимание
				концепции Solid и GRASP, модульность и паттерны, которые помогают поддерживать долгоживущее,
				масштабируемое и
				удобное для развития приложение;</li>
			<li>AI использование AI ускоряет разработку и делает кодинг эффективнее, но инженеры должны осознавать, что
				происходит «под капотом», чтобы не терять профессионализм. AI помогает генерировать код и
				автоматизировать
				рутинные задачи, усиливая разработчика, а не заменяя его полностью;</li>
			<li>DevOps: это некий стандарт для любого разработчика, нужно понимать, что такое pull request,CI/CD, GitHub
				Actions или Jenkins, Docker, общие представления о Kubernetes и Nginx, основах сети (DNS, CDN,
				HTTP/HTTPS,
				cookies, кросс-доменные запросы), чтобы работать с типовыми DevOps-процессами в команде.</li>
			<li>Security: важно понимать основы безопасности на frontend. Нужно уметь предотвращать инъекции опасного
				кода,работать с безопасными cookies,хранить токены авторизации с минимальным риском утечки;</li>
			<li>Agile: важно иметь практическое понимание гибких методологий разработки — спринты, Agile, Scrum. Опыт
				работы в коммерческих проектах приветствуется;</li>
			<li>Algorithms: умение оценивать сложность кода (O(n), O(n²), O(log n)), понимание трудоемкости операций и
				базовое знание структур данных (массивы, хэши, древовидные структуры);</li>
			<li>Git: уверенная работа с ветками, commit, pull request, merge, rebase, разрешение конфликтов и др.
				Глубокое понимание Git важно для командной работы и продакшена, так как помогает избежать потери
				изменений и ошибок;</li>
			<li>Backend: хорошее знание backend — от BFF(backend for frontend) до самостоятельной простой разработки.
				Понимание стоимости и сложности запросов, пути данных от frontend к серверу и обратно. Такое понимание
				повышает вашу ценность как frontend-инженера.</li>
		</ul>
	</div>
	<div>
		<h1>Samurai way. Vanilla front 02</h1>

		<img src="../assets/les02/les0201.png" width="720" height="480" />
		<ul>
			Схема начала работы может быть представлена следующим образом:
			<li>
				Пользователь открывает браузер.
			</li>
			<li>Вводит адрес сайта в адресной строке.</li>
			<li>Браузер через DNS определяет IP-адрес сервера и отправляет HTTP-запрос.</li>
			<li>Сервер по адресу понимает, какой файл нужно вернуть (например, index.html).</li>
			<li>HTML-файл загружается в браузер.</li>
		</ul>


		<ul>
			HTML как контейнер приложения
			<li>
				В классическом сайте HTML содержит много тегов и статическую вёрстку.
			</li>
			<li>В современном frontend-приложении index.html — это контейнер, в котором оживает приложение на
				JavaScript.</li>
			<li>Внутри обычно есть:
				"div id="root">div"
				Этот элемент служит контейнером для всего приложения. Идентификатор может быть любым, но чаще всего —
				root, app или main.
				Без JavaScript страница выглядит «пустой» — приложение оживает только после загрузки JS-кода.
			</li>
		</ul>

		<ul>
			Декомпозиция приложения
			JavaScript-код разделяется на два файла:
			html
			script src="data.js">/script
			script src="ui.js">/script
			<li>
				Работа с данными(Data.js) — бизнес-логика, хранение информации.
			</li>
			<li>
				Работа с отрисовкой(UI.js) — отвечает за отрисовку и визуализацию данных (UI). Такая декомпозиция
				помогает отделить логику от представления. В src указываем, откуда подгружать скрипт.
			</li>
		</ul>

		<div>
			Парсинг HTML и DOM
			<div>
				Для браузера index.html — это просто текст. Он парсит(читает) текст скрипта, разбирает его на теги,
				атрибуты и превращает их в DOM-дерево. DOM — это иерархия объектов, которая описывает структуру
				документа. JS работает именно с DOM-объектами, а не с «тегами» как строками. Изменения в DOM
				автоматически отображаются браузером.
			</div>
			<div>
				DOM-дерево(Document Object Model) — это объектная модель документа, которая представляет все содержимое
				страницы в виде объектов, которые можно добавлять,изменять, удалять.
			</div>

			<div>
				Работа с данными (Data.js)
				<ul>Файл данных обычно содержит:
					<li>Объекты</li>
					<li>Массивы</li>
					<li>Массивы объектов</li>
				</ul>
				Это позволяет удобно хранить и обрабатывать информацию (например, список треков).
				<pre><code class="language-javascript"arai-label="Пример JavaScript">
const tracks = [
  { id: 1, title: "Song A", src: "song-a.mp3" },
  { id: 2, title: "Song B", src: "song-b.mp3" },
]
				</code></pre>
				Файл загружается и выполняется первым.
			</div>
			<div>Работа с UI (UI.js)
				<ul>
					<li>Загружается после Data.js.</li>
					<li>Не хранит данные, а отвечает только за их отрисовку.</li>
					<li>Ищет root-элемент по id:</li>
					<pre><code class="language-javascript"arai-label="Пример JavaScript">
const root = document.getElementById("root")</code></pre>
			</div>
			<li>Создаёт новые DOM-элементы. С помощью forEach пробегаемся по массиву треков и для каждого трека
				выполняем последовательность действий:</li>
			<pre><code class="language-javascript"arai-label="Пример JavaScript">
const listEl = document.createElement("ul") //создаём список (ul) треков.
tracks.forEach((track) => {
const itemEl = document.createElement("li") //создаём элемент списка (li) для трека.
const audioEl = document.createElement("audio") //создаём аудиоэлемент (audio)
audioEl.src = track.src //задаём src (адрес аудиофайла)
	itemEl.appendChild(audioEl) //вставляем аудио в элемент списка
	listEl.appendChild(itemEl) //вставляем список в элемент root
})
root.appendChild(listEl)
		</div>
		</ul>
	
	<div>
		Практика с Vanilla JS
		<ul>Что такое localhost и порт
			<li>localhost — особое доменное имя. Браузер понимает его как «обратись к самому себе». То есть запрос не идёт в интернет, а возвращается на этот же компьютер.</li>
			<li>Железным сервером в данном случае выступает сам ноутбук/ПК.</li>
			<li>Программным сервером выступает софт (WebStorm, Live Server и т.д.), который слушает определённый порт и отдаёт файлы.</li>
		</ul>
		Номер порта нужен, чтобы несколько программ на одном компьютере могли работать с сетью одновременно. Каждая «занимает» свой порт.
	<ul>
		Добавляем музыку 🎵 на нашу страницу
		<li>В li вставляем тег audio.</li>
		<li>Тег audio отображается в браузере только если есть атрибут controls.</li>
		<li>В src указываем ссылку на .mp3 (из MusicFun API).</li>
	</ul>
	Получается минимальный музыкальный плеер на чистом HTML.
	<pre><code class="language-html"arai-label="Пример JavaScript">
		<xmp>
<ul>
 <li>
  <div>Musicfun soundtrack</div>
   <audio controls src="https://musicfun.it-incubator.app/api/samurai-way-soundtrack.mp3"></audio>
  </li>
  <li>
   <div>Musicfun soundtrack instrumental</div>
    <audio
     controls
     src="https://musicfun.it-incubator.app/api/samurai-way-soundtrack-instrumental.mp3"
    ></audio>
   </li>
</ul></xmp>
</code></pre>
		</div>

		<img src="../assets/les02/les0202.png" width="720" height="480" />

		<div>
			<ul>Проверка в DevTools → Network
				<li>
					Открываем вкладку Network (F12 → Network). Обновляем страницу:
				</li>
				<li>1. Загружается наш index.html.</li>
				<li>2. Подтягиваются встроенные картинки (дефолтные кнопки плеера).</li>
				<li>3. Запрашиваются музыкальные файлы с сервера (.mp3). При первой подгрузке загружается только превью,
					а
					не
					весь трек. А уже при нажатии play загружается полный трек.</li>
				<li>4. Устанавливается WebSocket-соединение для автообновления страницы.</li>
				<li>5. Подгружается фавиконка</li>
			</ul>
		</div>
		<div>
			Создание frontend-приложения
			<ul>🤔 Так зачем нам все-таки делать HTML пустым и оживлять с помощью JS, если все работает и без этого?
				<li>Статический HTML — это как написанное «на бумаге»: данные зафиксированы и не меняются.</li>
				<li>Но данные в реальности динамичны:</li>
				<li>могут появляться новые треки, изменяться названия, ссылки;</li>
				<li>возможны сортировки, фильтры, лайки, подписки и т.п.</li>
				<li>Если всё «зашить» прямо в HTML, придётся вручную копировать-разметку и править её. Это неудобно и не
					масштабируется.</li>
				Поэтому:
				<li>HTML делают максимально пустым (например, только div id="root">/div).</li>
				<li>Дальше всё наполняется с помощью JS, который:</li>
				<li>берёт данные (массив объектов треков);</li>
				<li>по алгоритму создаёт DOM-элементы (заголовки, списки, плееры);</li>
				<li>вставляет их на страницу.</li>
			</ul>
			<ul>Редактируем наш код
				<li>1. Создаем файл main.js</li>
				<li>2. Из index.html удаляем все лишнее</li>
				<li>3. Подключаем main.js в index.html</li>
			</ul>

			Описываем данные
			<div>
				Создаем массив tracks с объектами треков, которые содержат название трека(title) и ссылку на сам
				аудиофайл(url):
				<pre><code>
const tracks = [
  {
    title: "Musicfun soundtrack",
    url: "https://musicfun.it-incubator.app/api/samurai-way-soundtrack.mp3",
  },
  {
    title: "Musicfun soundtrack instrumental",
    url: " https://musicfun.it-incubator.app/api/samurai-way-soundtrack-instrumental.mp3",
  },
];
			</code></pre>
				Данные отделены от кода отрисовки — можно добавлять новые треки, не меняя алгоритм.
			</div>

			<ul>Создание элементов
				<li>Находим наш корневой div по id. Используем document.getElementById("root").</li>
				<li>Все новые элементы вставляются внутрь него.</li>
				<pre><code>
const rootEl = document.getElementById("root") // Находим наш корневой <div> по id
 const headerEl = document.createElement("h1") // создаем тег заголовка для страницы
 headerEl.append("Musicfun Player") // добавляем текст в заголовок
 rootEl.append(headerEl) //добавляем заголовок в корневой div
		 
 const tracksEl = document.createElement("ul") //создаем список треков
</code></pre>
				<li>Теперь для каждого трека нам необходимо создать:</li>
				<li>li — обёртка для трека</li>
				<li>div с названием трека;</li>
				<li>audio с атрибутом controls и src = track.src; Чтобы не писать одно и тоже много раз воспользуемся
					методом массива forEach</li>
				<li></li>
				<pre><code>
tracks.forEach((track) => {
 const trackEL = document.createElement("li") //создаем элемент трека
 const trackTitleEL = document.createElement("div") // создаем элемент для заголовка трека
 trackTitleEL.append(track.title) // добавляем заголовок трека в наш div
 trackEL.append(trackTitleEL) //добавляем элемент заголовка в трек
				   
 const trackPlayerEL = document.createElement("audio") //создаем тег audio
 trackPlayerEL.controls = true // говорим, что нам нужен интерфейс управления аудио
 trackPlayerEL.src = track.url //добавляем ссылку на наш файл
 trackEL.append(trackPlayerEL) // и добавляем весь аудио элемент в наг трек
				   
  tracksEl.append(trackEL) //добавляем трек в список треков
  })
 rootEl.append(tracksEl) // и теперь добавляем список треков в наш корневой div-элемент
			</code></pre>

			</ul>
			🚀 Вот и готово первое frontend-приложение!

			<ul>Важные архитектурные идеи
				<li>Разделение данных и рендеринга:</li>
				<li>данные → массив объектов;</li>
				<li>рендеринг → алгоритм отрисовки;</li>
				<li>добавление новых треков не требует менять логику.</li>
				<li>DOM-дерево динамическое: изначально пустое, браузер наполняет его из JS.</li>
				<li>Алгоритм универсален: работает одинаково, по некому шаблону для любого количества данных.</li>

			</ul>

			<ul>
				Недостатки нативного подхода
				<li>Код быстро становится громоздким:</li>
				<li>множество createElement, append, вложенностей;</li>
				<li>сложно читать структуру;</li>
				<li>при условной отрисовке появляются if/else, усложняющие код.</li>
				<li>Вёрстка современных приложений слишком сложная, чтобы делать всё руками.</li>
				Тут на помощь приходят фреймворки (React, Vue, Angular) со своими преимуществами:
				<li>упрощают работу с DOM (не нужно вручную создавать и вкладывать элементы);</li>
				<li>автоматически обновляют интерфейс при изменении данных;</li>
				<li>позволяют сосредоточиться на данных и бизнес-логике, а не на DOM.</li>
				❗Нативный JS не теряет свою важность! Чтобы быть профессионалами своего дела мы должны:
				<li>понимать, что делает фреймворк «под капотом».</li>
				<li>оценивать «стоимость» операций в DOM.</li>
				<li>уметь дебажить проблемы производительности.</li>
			</ul>

			🏠 Домашнее задание
			На основе изученного примера с музыкальным плеером создать веб-страницу со списком дел, где каждая задача
			имеет
			название и статус выполнения.

			Результат:
			<div id="homework02">

			</div>
			<link rel="stylesheet" href="../homework/les02/todo.css">
			</link>
			<script src="../homework/les02/todo.js"></script>
		</div>
	</div>
	<div>
		<h1>Браузер vs Node.js: среды выполнения JavaScript 03</h1>
		<ul>Браузер
			<li>Основная среда фронтенд-разработки.</li>
			<li>JS изначально создавался для браузеров.</li>
			<li>Добавляет свои "фишки" для работы с DOM (document, body, createElement).</li>
			<li>Ограничения: нельзя работать с файлами, запускать процессы, браузер действует как «песочница» для
				безопасности.</li>
		</ul>

		<ul>Node.js
			<li>Платформа для запуска JS вне браузера.</li>
			<li>Использует тот же движок V8, что Chrome(браузер).</li>
			<li>Расширенные возможности: работа с файлами, базами данных, запросами, запуск внешних процессов.</li>
			<li>Предназначен для разработчиков.</li>
			<li>Программы для браузера могут не работать в Node.js и наоборот из-за разных API.</li>
		</ul>
		<img src="../assets/les03/les0301.png" width="720" height="480" />

		Современный frontend-проект: зависимости, библиотеки и фреймворки
		<div>
			Современные приложения состоят не только из проектозависимого кода, но и из множества сторонних библиотек и
			инструментов.
			<ul>Библиотеки
				<li>
					Универсальные инструменты (libraries), которые не зависят от проекта, а предоставляют какую-то
					полезную функцию: работа с данными, графиками, SPA, эффективные запросы на сервер.
				</li>
				<li>Подключаются к HTML напрямую (например, React).</li>

			</ul>
			Фреймворк - структура, определяющая логику работы приложения (например, Angular).
			Библиотеки и фреймворки помогают сосредоточиться на уникальном коде, а не на повторяющихся задачах.
			<ul>Dependencies (зависимости)
				<li>
					В проекте всегда есть множество сторонних библиотек, необходимых для работы приложения.
				</li>
				<li>
					Node.js помогает управлять зависимостями и делает проект независимым от среды разработки.
				</li>
			</ul>

			<ul>Что нужно делать до запуска приложения
				<li>Транспиляция: TypeScript → JavaScript (браузер понимает только JS).</li>
				<li>Склейка или разделение файлов проекта.</li>
				<li>Преобразование стилей: SASS/LESS → CSS.(браузер понимает только CSS)</li>
				<li>Проверка кода, тестирование, запуск утилит.</li>
			</ul>
			<ul>Почему Node.js нужен для этого
				<li>Без Node.js выполнение этих задач зависит от IDE(среды разработки) или расширений браузера.</li>
				<li>Node.js позволяет автоматизировать процесс, управлять DevDependencies — библиотеками, необходимыми
					"на этапе разработки" и делать проект независимым от среды разработки.</li>
			</ul>
			<ul>npm (Node Package Manager)
				<li>Менеджер пакетов, который устанавливается вместе с Node.js.</li>
				<li>Позволяет добавлять, обновлять и удалять библиотеки.</li>
			</ul>
			<ul>npx (Node Package Execute)
				<li>Используется для запуска пакетов и утилит напрямую без установки.</li>
			</ul>
			На старте можно не вникать в детали Node.js и npm — они будут работать сами.

			Вывод
			<ul>Node.js — ключевая платформа современной frontend-разработки. Она позволяет:
				<li>Автоматизировать сборку проекта.</li>
				<li>Управлять зависимостями.</li>
				<li>Запускать вспомогательные инструменты (транспиляторы, препроцессоры, сборщики).</li>
				Понимание и использование Node.js — необходимый навык для любого современного frontend-инженера.
			</ul>

			🏠 Домашнее задание
			<div>
				Установить Node.js на свой компьютер и проверить корректность установки.
				<img src="../assets/les03/les0302.png" width="600" height="200" />
			</div>
		</div>

	</div>
	<div>
		<h1>Боевой маршрут (React Путь Самурая: без альтернатив) 4</h1>
		Установка Vite
		<div>
			Vite — это инструмент сборки, призванный обеспечить более быструю и эффективную разработку современных
			веб-проектов. Он автоматически подтягивает зависимости и конфигурирует проект.

			Scaffolding — это создание базового шаблона проекта со всеми нужными папками, файлами и зависимостями.
			<ul>
				<li>1. Переходим на сайт
					<a href="https://vite.dev/">vite.dev</a> → раздел Get Started.
				</li>
				<li>2.В документации находим секцию Scaffolding Your First Vite Project.</li>
				<li>3.У себя на компьютере открываем папку, в которой хотим создать проект.</li>
				<li>4.В этой папке запускаем терминал.</li>
				<li>5.В терминале вводим</li>

				<pre><code>
npm create vite@latest
			</code></pre>

				<ul>
					<li>
						npm — пакетный менеджер, который идёт вместе с Node.js. Иногда встречается npx, но сейчас его
						функциональность встроена в npm.
					</li>
					<li>
						npm create — специальная команда для запуска генераторов (в данном случае — Vite).
					</li>
					Здесь вводим y, подтверждаем, что мы хотим установить Vite
				</ul>

				6.Вводим имя папки, например:
				</li>


		</div>

		<img src="../assets/les04/les0401.png" width="600" height="200" />
		<ul>
			Название папки:
			<li>в нижнем регистре (lowerCase)</li>
			<li>используем латинский алфавит</li>
			<li>не используем специальные символы/li>
			<li>не ставим пробелы</li>
		</ul>

		<li>7.dВыбираем фреймворк из предложенных. Мы разрабатываем react приложение, соответственно выбираем
			React.</li>
		<img src="../assets/les04/les0403.png" width="600" height="200" />
		<li>8.Выбор языка. Выбираем TypeScript, в дальнейших уроках будем разбирать и изучать данный язык.</li>
		<img src="../assets/les04/les0404.png" width="600" height="200"></img>
		<li>9.Если все успешно видим:</li>
		<img src="../assets/les04/les0405.png" width="600" height="200"></img>
		</ul>

	</div>
	Открытие проекта в IDE
	Откроем проект в WebStorm (или другой IDE). При создании Vite сразу подготовил нам структуру проекта с множеством
	файлов и папок. Жмем правой кнопкой мыши по папке проекта и выбираем Open folder as WebStorm project

	Package.json
	<div>
		Почему папка считается Node.js-проектом?
		<ul>
			Определяющим фактором является наличие файла package.json. Он выполняет несколько функций:
			<li>задаёт описание проекта для Node.js,</li>
			<li>фиксирует список зависимостей,</li>
			<li>хранит скрипты для запуска и сборки.</li>
		</ul>
		Если в папке нет package.json, Node.js не воспринимает её как проект.
		Dependencies и DevDependencies

		Внутри package.json есть две ключевые секции:

		<div>
			1. Dependencies
			<ul>
				Это библиотеки, которые непосредственно попадут в браузер и будут выполняться как часть
				frontend-приложения. В нашем случае:
				<li>react</li>
				<li>react-dom</li>
				Они нужны для построения интерфейса и работы с DOM, без необходимости вручную управлять
				низкоуровневым API браузера и непосредственного взаимодействия с DOM-элементами.

			</ul>
			2. DevDependencies
			<ul>
				Это пакеты, которые нужны только на этапе разработки:
				<li>транспиляция (TypeScript → JS)</li>
				<li>бандлинг</li>
				<li>плагины для Vite</li>
				<li>ESLint</li>
				<li>TypeScript и его конфигурации</li>
				Именно сюда входит сам Vite и вспомогательные инструменты. Они не попадут в продакшн-сборку, но делают
				Developer Experience (DX) удобным. На данном этапе не нужно детально разбирать каждый пункт
				Dependencies.
			</ul>


		</div>

	</div>

	Как запустить приложение
	<div>
		<ul>Так как мы работаем с frontend-проектом, то мы не можем запустить его просто напрямую через node.js, так
			как:
			<li>используется TypeScript и JSX/TSX,</li>
			<li>код нужно транспилировать и собрать в бандл,</li>
			<li>требуется запустить локальный сервер, который отдаёт результат в браузер. Поэтому для запуска
				используется не node, а специальный скрипт, который подготовил Vite.</li>
		</ul>
		Установка зависимостей
		После генерации проекта у нас есть только package.json. В нём записаны только названия пакетов и их версии.
		Чтобы скачать все указанные пакеты из npm-реестра, нужно выполнить:
		<a>
			npm install</a>
		<ul>
			Что происходит при выполнении этой команды:
			<li>1. npm читает package.json.</li>
			<li>2. Скачивает указанные библиотеки из npm-реестра (центрального хранилища пакетов).</li>
			<li>3. Кладёт их в папку node_modules.</li>
			Эта папка может достигать больших размеров(сотни мегабайт, иногда гигабайты), поэтому она не хранится в
			репозитории и не передается другим разработчикам.❗Её всегда можно восстановить через npm install, так как
			все нужные пакеты указаны в package.json.
			<li>4. Создаёт файл package-lock.json с точными версиями установленных пакетов, чтобы у всех разработчиков
				был одинаковый набор.</li>
			Установка зависимостей нужна для того, чтобы превратить описание проекта в реальный работающий набор
			библиотек и инструментов.
		</ul>
		Запуск проекта
		<div>
			Vite для нас уже автоматически прописал в package.json удобный скрипт:
			<div>npm run dev</div>
			Этот скрипт находится в package.json в scripts
			<img src="../assets/les04/les0406.png" width="600" height="200"></img>
			Vite поднимет локальный сервер и выведет в терминал ссылку, например:
			<div>http://localhost:5173/</div>
			Перейдя по ней в браузере, вы увидите базовое React-приложение со счётчиком(на момент написания конспекта).
			Кнопка работает: при клике число увеличивается 🚀
			<img src="../assets/les04/les0407.png" width="720" height="480"></img>

		</div>
	</div>
	<div>Структура проекта
		<ul>
			<li>.idea/: Вспомогательные файлы IDE (WebStorm). Они не влияют на работу проекта. Может называться
				по-другому, в зависимости от IDE</li>
			<li>node_modules/: Содержит все установленные пакеты. Пока это все, что нам нужно знать.</li>
			<li>public/: Папка для статических файлов (картинок, шрифтов и т.п.). Например, здесь лежит маленькая
				fav-иконка, которая отображается во вкладке браузера.</li>
			<li>src/: Главная папка для разработчика. Здесь хранится исходный код: компоненты React, стили и всё, что мы
				пишем сами.</li>
		</ul>
		Главный HTML-файл
		<ul>
			<li>содержит тег div id="root">/div — это «контейнер», в который React будет «монтировать» приложение,</li>
			<li>подключает src/main.tsx как точку входа.</li>
			<pre>
		&ltbody&gt
			&ltdiv id="root"&gt/div&gt
			&ltscript type="module" src="/src/main.tsx"&gt &lt/script&gt
		&lt/body&gt;
</pre>
		</ul>

		Точка входа: main.tsx
		<div>Здесь начинает оживать наше React-приложение.</div>

		<pre>
		<code>
import { StrictMode } from "react"
import { createRoot } from "react-dom/client"
import "./index.css"
import App from "./App.tsx"
 
createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
		</code>
	</pre>

		<ul>
			<div>1. Импорты. Мы установили библиотеки, но чтобы их использовать в коде, мы должны их импортировать.
				Также
				импорты связывают файл, в котором мы работаем, с другими необходимыми локальными файлами:
				<li>Если путь начинается без ./ (например, createRoot): 👉 значит используется библиотека из
					node_modules.
				</li>
				<li>Если путь начинается с ./ или ../ (например App): 👉 значит подключаем файл из текущей папки (или
					соседней).</li>
				<li>Импорт JavaScript/TypeScript-файлов (.ts, .tsx) подключает функции, объекты, компоненты.</li>
				<li>Импорт CSS-файла (.css) просто добавляет стили к странице.</li>
			</div>
			<div>2. Далее мы видим React функцию createRoot, которая ищет в index.html элемент с id="root" и затем
				использует
				его как контейнер для нашего приложения. Оно монтируется внутрь этого &ltdiv id='root'&gt&lt/div&gt
			</div>
			<div>3. StrictMode - обёртка, которая помогает ловить ошибки и предупреждения на этапе разработки.
			</div>
			<div>4.$ltApp /$gt - компонент, главный строительный блок нашего приложения. Пользовательский HTML-тег,
				придуманный
				разработчиком. Схож с div или p, но это наш собственный элемент, который мы описали в App.tsx
			</div>
		</ul>

		Разобьем по пунктам. StrictMode пока уберем:
		<pre>
			<code>
const rootEl = document.getElementById("root")
const reactRoot = createRoot(rootEl!) // 💡 '!' - говорит TypeScript: "этот элемент точно существует".
reactRoot.render(<App />) // React "оживляет" HTML и вставляет разметку в root.
			</code>
		</pre>

		JSX — HTML внутри JavaScript
		<div>
			В React мы можем писать HTML-подобный синтаксис прямо в JS/TS:
			<div>reactRoot.render(%ltbutton%gtHello%lt/button%gt)</div>
			Это называется JSX - специальный синтаксис, который при компиляции превращается в вызовы функций JavaScript.
			Сам по себе браузер JSX не понимает. Перед тем как код попадёт в браузер, сборщик (Vite + TypeScript +
			Babel) переводит JSX в обычный JavaScript, который уже можно выполнить.
			Файлы, содержащие JSX-разметку имеют расширение .jsx, если код написан с использованием typescript, то
			расширение соответственно - .tsx
			<ul>
				⚡ Отличие от HTML в названиях:
				<li>Стандартные теги (div, button, h1 и т. д.) пишутся с маленькой буквы.</li>
				<li>Компоненты React пишутся с большой буквы:</li>
			</ul>
			<div>&ltApp /&gt // компонент</div>
			<div>&ltinput/&gt // обычный HTML-тег</div>

		</div>

		<div>
			Компонент - это функция, которая возвращает JSX - разметку. Внутри неё могут быть как обычные HTML-теги, так
			и другие компоненты. Возвращает один корневой элемент. Если нужно несколько тегов, то оборачиваем их
			фрагментом(пустым тегом). В итоге React преобразует компонент в обычные HTML-теги, и именно они попадают в
			браузер. Отображается не сам компонент, а итоговая HTML-структура.

			&lt&gt&lt/&gt - фрагмент - нужен для того, чтобы объединить несколько тегов вместе, не создавая настоящий
			HTML-элемент, например, div.

			<div><a href="https://react.dev/reference/react/Fragment">React документация: Fragment</a>
			</div>

			То, что выглядит как HTML в React, на самом деле является инструкциями JavaScript — указанием для React,
			какие элементы создавать и как обновлять их на странице. React берёт эти инструкции и эффективно управляет
			DOM, обновляя интерфейс без полной перезагрузки страницы.

			❗Однако одну из ключевых концепций мы все же нарушили: данные должны быть отделены от алгоритма рендеринга.
			Давайте вернём это разделение, чтобы компонент стал гибким и легко управляемым.
		</div>

		Создание универсального алгоритма
		<div>Здесь важно, что наши теги все еще являются
			HTML-разметкой,
			поэтому весь текст, написанный внутри тега воспринимается как обычный текст. Чтобы указать, что мы хотим
			написать именно код, необходимо использовать фигурные скобки - {} - JSX expression</div>

	</div>

	<div>
		Каждый раз, когда мы возвращаемся в браузер наши изменения уже отобразились. Это происходит благодаря hot
		reloading, который использует Vite. В отличие от обычной перезагрузки страницы, когда всё приложение полностью
		обновляется и “умирает”, hot reloading подменяет только изменённые файлы.
	</div>
	<div>
		Наша конечная цель — получить массив React-элементов динамически, пробежавшись по исходному массиву данных.
		Когда нужно создать новый массив объектов на основе существующего массива, в JavaScript используется метод
		массива map.
	</div>
	<div>
		Важно помнить: в отличие от forEach, который ничего не возвращает, метод map создаёт новый массив, содержащий
		столько же элементов, сколько и исходный. Таким образом, мы получили универсальный алгоритм отрисовки: если
		добавить новые треки в массив данных, они автоматически появятся в браузере, без необходимости вручную менять
		разметку.
	</div>
	<ul>
		Итог
		<li>
			На практике современные React-разработчики чаще вставляют сам вызов map прямо внутрь JSX — например, внутрь
			$ltul$gt в фигурных скобках. Результатом работы map будет новый массив React-элементов, и React
			автоматически
			отрисует каждый элемент этого массива.
		</li>
		<li>Для правильной работы React требует специальный атрибут key для каждого элемента списка. Он позволяет React
			правильно отслеживать элементы при обновлениях. В HTML это выглядит как обычный атрибут, в React это
			называется props. Для key обычно используют уникальный идентификатор сущности(id), например id трека.
			Добавив этот key, мы устраняем предупреждение и делаем наш код правильным — готовым к использованию в
			реальных проектах.</li>
	</ul>
	🏠Домашнее задание
	Создание React приложения со списком дел
	<ul>
		<li>Цель задания
			Создать React приложение с использованием Vite и отрисовать интерактивный список дел, применив знания о
			компонентах, JSX и методе map.
		</li>
		<li>
			Задача
			На основе изученного примера с музыкальным плеером создать React приложение со списком задач, где каждая
			задача имеет название и статус выполнения.
		</li>
	</ul>
	<ul>Требования
		<li>
			1. Создать новое React приложение на Vite
		</li>
		<li>2.Установить зависимости</li>
		<li>3.Запустить приложение. После выполнения команды откройте браузер и перейдите по адресу, который покажет в
			терминале (обычно http://localhost:5173).</li>
	</ul>

	JSX структура
	<ul>
		Создайте следующую структуру в return компонента:
		<li>1. Заголовок - элемент h1 с текстом "Список дел"</li>
		<li>2. Список задач - элемент ul со списком всех задач</li>
		<li>3.Каждая задача должна быть элементом li, содержащим:</li>
		<li>
		<li>div с названием задачи </li>
		<li>input типа checkbox для отображения статуса выполнения</li>
		</li>
	</ul>

	<ul>
		Технические детали
		<li>Используйте метод .map() для отрисовки списка задач</li>
		<li>Не забудьте про атрибут key - используйте task.id</li>
		<li>Устанавливайте тип чекбокса: type="checkbox"</li>
	</ul>
	</div>
	<!-- <script src="../homework/les05/map.js"></script> -->
	<script type="module" src="../homework/les06/main.js"></script>






</body>

</html>