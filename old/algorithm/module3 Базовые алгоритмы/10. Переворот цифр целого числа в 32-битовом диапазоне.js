/*

Переворот цифр целого числа в 32-битовом диапазоне
Учитывая целое число x со знаком в 32 бита, верните x с перевёрнутыми цифрами. Если обратное x приводит к значению, выходящему за границы диапазона целых чисел в 32 бита [-2**31, 2**31 - 1], то верните 0.

Предположим, что среда не позволяет вам хранить 64-битные целые числа (со знаком или без знака).

Пример 1:

**Ввод:** x = 123
**Вывод:** 321
Пример 2:

**Ввод:** x = -123
**Вывод:** -321
Пример 3:

**Ввод:** x = 120
**Вывод:** 21
Ограничения:

-2**31 <= x <= 2**31 - 1
Алгоритм 1
Интуиция

Мы можем построить обратное целое число, по одной цифре за раз. При этом мы можем предварительно проверить, приведет ли добавление еще одной цифры к переполнению.

Алгоритм

Обратное целое число можно получить аналогично обратному порядку символов в строке.

Мы хотим повторять операцию «выталкивания» последней цифры из числа xxx и перемещения ее в конец rev\text{rev}rev. В конечном итоге rev\text{rev}rev станет обратным к ххх.

Для «выталкивания» и «помещения» цифр без помощи стека/массива можно использовать математику.

// операция выталкивания: pop = x % 10; x /= 10;

// операция помещения: temp = rev * 10 + pop; rev = temp;

Однако этот подход опасен, потому что операция temp=rev⋅10+pop\text{temp} = \text{rev} \cdot 10 + \text{pop}temp=rev⋅10+pop может вызвать переполнение.

К счастью, легко проверить заранее, вызовет ли данное выражение переполнение.

Для объяснения предположим, что rev\text{rev}rev положителен.

Если temp=rev⋅10+poptemp = \text{rev} \cdot 10 + \text{pop}temp=rev⋅10+pop вызывает переполнение, то это означает, что rev≥INTMAX10\text{rev} \geq \frac{INTMAX}{10}rev≥10INTMAX​
Если rev>INTMAX10\text{rev} > \frac{INTMAX}{10}rev>10INTMAX​, то temp=rev⋅10+poptemp = \text{rev} \cdot 10 + \text{pop}temp=rev⋅10+pop гарантировано вызовет переполнение.
Если rev==INTMAX10\text{rev} == \frac{INTMAX}{10}rev==10INTMAX​, то temp=rev⋅10+poptemp = \text{rev} \cdot 10 + \text{pop}temp=rev⋅10+pop вызовет переполнение, если и только если pop>7\text{pop} > 7pop>7
Аналогичная логика может быть применена, когда rev\text{rev}rev отрицательное.

Анализ сложности

Временная сложность: O(log⁡(x))O(\log(x))O(log(x)). В числе ххх примерно log⁡10(x)\log_{10}(x)log10​(x) цифр.
Пространственная сложность: O(1)O(1)O(1).


*/
function reverse(x) {
  let rev = 0;
  while (x !== 0) {
    let pop = x % 10;
    x = parseInt(x / 10);
    if (
      rev > Number.MAX_VALUE / 10 ||
      (rev === Number.MAX_VALUE / 10 && pop > 7)
    )
      return 0;
    if (
      rev < Number.MIN_VALUE / 10 ||
      (rev === Number.MIN_VALUE / 10 && pop < -8)
    )
      return 0;
    rev = rev * 10 + pop;
  }
  return rev;
}
