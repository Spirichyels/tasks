<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
</head>

<body>

	<div>
		<h1>Выучи ReactJS, устройся на работу. Введение 01</h1>
		<img src="/assets/les01/les0102.png" width="720" height="480" />
		<ul>
			<li>
				ReactJS: нужно уверенно владеть почти всем API React. Мы должны быть мастерами React. Около 10%
				возможностей (для метафреймворков и сложных библиотек) достаточно знать на уровне «слышал».
			</li>
			<li>JS: требуется глубокое знание языка: замыкания, классы, промисы и другие ключевые механизмы;</li>
			<li>>HTML/CSS: на том же уровне. При хорошем знании React и JS верстку можно быстро подтянуть по мере
				необходимости;</li>
			<li>TS: практическое использование типизации для выявления ошибок на этапе разработки и строгого контроля
				передачи
				данных между слоями и функциями. Особенно важно для утилитного и масштабируемого ПО, где строгая
				типизация
				помогает поддерживать стабильность и предсказуемость кода;</li>
			<li>Architecture: уже не только структура папок. Важно закладывать архитектурный фундамент проекта.
				Понимание
				концепции Solid и GRASP, модульность и паттерны, которые помогают поддерживать долгоживущее,
				масштабируемое и
				удобное для развития приложение;</li>
			<li>AI использование AI ускоряет разработку и делает кодинг эффективнее, но инженеры должны осознавать, что
				происходит «под капотом», чтобы не терять профессионализм. AI помогает генерировать код и
				автоматизировать
				рутинные задачи, усиливая разработчика, а не заменяя его полностью;</li>
			<li>DevOps: это некий стандарт для любого разработчика, нужно понимать, что такое pull request,CI/CD, GitHub
				Actions или Jenkins, Docker, общие представления о Kubernetes и Nginx, основах сети (DNS, CDN,
				HTTP/HTTPS,
				cookies, кросс-доменные запросы), чтобы работать с типовыми DevOps-процессами в команде.</li>
			<li>Security: важно понимать основы безопасности на frontend. Нужно уметь предотвращать инъекции опасного
				кода,работать с безопасными cookies,хранить токены авторизации с минимальным риском утечки;</li>
			<li>Agile: важно иметь практическое понимание гибких методологий разработки — спринты, Agile, Scrum. Опыт
				работы в коммерческих проектах приветствуется;</li>
			<li>Algorithms: умение оценивать сложность кода (O(n), O(n²), O(log n)), понимание трудоемкости операций и
				базовое знание структур данных (массивы, хэши, древовидные структуры);</li>
			<li>Git: уверенная работа с ветками, commit, pull request, merge, rebase, разрешение конфликтов и др.
				Глубокое понимание Git важно для командной работы и продакшена, так как помогает избежать потери
				изменений и ошибок;</li>
			<li>Backend: хорошее знание backend — от BFF(backend for frontend) до самостоятельной простой разработки.
				Понимание стоимости и сложности запросов, пути данных от frontend к серверу и обратно. Такое понимание
				повышает вашу ценность как frontend-инженера.</li>
		</ul>
	</div>
	<div>
		<h1>Samurai way. Vanilla front 02</h1>

		<img src="/assets/les02/les0201.png" width="720" height="480" />
		<ul>
			Схема начала работы может быть представлена следующим образом:
			<li>
				Пользователь открывает браузер.
			</li>
			<li>Вводит адрес сайта в адресной строке.</li>
			<li>Браузер через DNS определяет IP-адрес сервера и отправляет HTTP-запрос.</li>
			<li>Сервер по адресу понимает, какой файл нужно вернуть (например, index.html).</li>
			<li>HTML-файл загружается в браузер.</li>
		</ul>


		<ul>
			HTML как контейнер приложения
			<li>
				В классическом сайте HTML содержит много тегов и статическую вёрстку.
			</li>
			<li>В современном frontend-приложении index.html — это контейнер, в котором оживает приложение на
				JavaScript.</li>
			<li>Внутри обычно есть:
				"div id="root">div"
				Этот элемент служит контейнером для всего приложения. Идентификатор может быть любым, но чаще всего —
				root, app или main.
				Без JavaScript страница выглядит «пустой» — приложение оживает только после загрузки JS-кода.
			</li>
		</ul>

		<ul>
			Декомпозиция приложения
			JavaScript-код разделяется на два файла:
			html
			script src="data.js">/script
			script src="ui.js">/script
			<li>
				Работа с данными(Data.js) — бизнес-логика, хранение информации.
			</li>
			<li>
				Работа с отрисовкой(UI.js) — отвечает за отрисовку и визуализацию данных (UI). Такая декомпозиция
				помогает отделить логику от представления. В src указываем, откуда подгружать скрипт.
			</li>
		</ul>

		<div>
			Парсинг HTML и DOM
			<div>
				Для браузера index.html — это просто текст. Он парсит(читает) текст скрипта, разбирает его на теги,
				атрибуты и превращает их в DOM-дерево. DOM — это иерархия объектов, которая описывает структуру
				документа. JS работает именно с DOM-объектами, а не с «тегами» как строками. Изменения в DOM
				автоматически отображаются браузером.
			</div>
			<div>
				DOM-дерево(Document Object Model) — это объектная модель документа, которая представляет все содержимое
				страницы в виде объектов, которые можно добавлять,изменять, удалять.
			</div>

			<div>
				Работа с данными (Data.js)
				<ul>Файл данных обычно содержит:
					<li>Объекты</li>
					<li>Массивы</li>
					<li>Массивы объектов</li>
				</ul>
				Это позволяет удобно хранить и обрабатывать информацию (например, список треков).
				<pre><code class="language-javascript"arai-label="Пример JavaScript">
const tracks = [
  { id: 1, title: "Song A", src: "song-a.mp3" },
  { id: 2, title: "Song B", src: "song-b.mp3" },
]
				</code></pre>
				Файл загружается и выполняется первым.
			</div>
			<div>Работа с UI (UI.js)
				<ul>
					<li>Загружается после Data.js.</li>
					<li>Не хранит данные, а отвечает только за их отрисовку.</li>
					<li>Ищет root-элемент по id:</li>
					<pre><code class="language-javascript"arai-label="Пример JavaScript">
const root = document.getElementById("root")</code></pre>
			</div>
			<li>Создаёт новые DOM-элементы. С помощью forEach пробегаемся по массиву треков и для каждого трека
				выполняем последовательность действий:</li>
			<pre><code class="language-javascript"arai-label="Пример JavaScript">
const listEl = document.createElement("ul") //создаём список (ul) треков.
tracks.forEach((track) => {
const itemEl = document.createElement("li") //создаём элемент списка (li) для трека.
const audioEl = document.createElement("audio") //создаём аудиоэлемент (audio)
audioEl.src = track.src //задаём src (адрес аудиофайла)
	itemEl.appendChild(audioEl) //вставляем аудио в элемент списка
	listEl.appendChild(itemEl) //вставляем список в элемент root
})
root.appendChild(listEl)
		</div>
		</ul>
	</div>
	<div>
		Практика с Vanilla JS
		<ul>Что такое localhost и порт
			<li>localhost — особое доменное имя. Браузер понимает его как «обратись к самому себе». То есть запрос не идёт в интернет, а возвращается на этот же компьютер.</li>
			<li>Железным сервером в данном случае выступает сам ноутбук/ПК.</li>
			<li>Программным сервером выступает софт (WebStorm, Live Server и т.д.), который слушает определённый порт и отдаёт файлы.</li>
		</ul>
		Номер порта нужен, чтобы несколько программ на одном компьютере могли работать с сетью одновременно. Каждая «занимает» свой порт.
	<ul>
		Добавляем музыку 🎵 на нашу страницу
		<li>В li вставляем тег audio.</li>
		<li>Тег audio отображается в браузере только если есть атрибут controls.</li>
		<li>В src указываем ссылку на .mp3 (из MusicFun API).</li>
	</ul>
	Получается минимальный музыкальный плеер на чистом HTML.
	<pre><code class="language-html"arai-label="Пример JavaScript">
		<xmp>
<ul>
 <li>
  <div>Musicfun soundtrack</div>
   <audio controls src="https://musicfun.it-incubator.app/api/samurai-way-soundtrack.mp3"></audio>
  </li>
  <li>
   <div>Musicfun soundtrack instrumental</div>
    <audio
     controls
     src="https://musicfun.it-incubator.app/api/samurai-way-soundtrack-instrumental.mp3"
    ></audio>
   </li>
</ul></xmp>
</code></pre>
		</div>
	</div>
	<img src="/assets/les02/les0202.png" width="720" height="480" />

	<div>
		<ul>Проверка в DevTools → Network
			<li>
				Открываем вкладку Network (F12 → Network). Обновляем страницу:
			</li>
			<li>1. Загружается наш index.html.</li>
			<li>2. Подтягиваются встроенные картинки (дефолтные кнопки плеера).</li>
			<li>3. Запрашиваются музыкальные файлы с сервера (.mp3). При первой подгрузке загружается только превью, а
				не
				весь трек. А уже при нажатии play загружается полный трек.</li>
			<li>4. Устанавливается WebSocket-соединение для автообновления страницы.</li>
			<li>5. Подгружается фавиконка</li>
		</ul>
	</div>
	<div>
		Создание frontend-приложения
		<ul>🤔 Так зачем нам все-таки делать HTML пустым и оживлять с помощью JS, если все работает и без этого?
			<li>Статический HTML — это как написанное «на бумаге»: данные зафиксированы и не меняются.</li>
			<li>Но данные в реальности динамичны:</li>
			<li>могут появляться новые треки, изменяться названия, ссылки;</li>
			<li>возможны сортировки, фильтры, лайки, подписки и т.п.</li>
			<li>Если всё «зашить» прямо в HTML, придётся вручную копировать-разметку и править её. Это неудобно и не
				масштабируется.</li>
			Поэтому:
			<li>HTML делают максимально пустым (например, только div id="root">/div).</li>
			<li>Дальше всё наполняется с помощью JS, который:</li>
			<li>берёт данные (массив объектов треков);</li>
			<li>по алгоритму создаёт DOM-элементы (заголовки, списки, плееры);</li>
			<li>вставляет их на страницу.</li>
		</ul>
		<ul>Редактируем наш код
			<li>1. Создаем файл main.js</li>
			<li>2. Из index.html удаляем все лишнее</li>
			<li>3. Подключаем main.js в index.html</li>
		</ul>
	</div>




</body>

</html>