/*

Уникальные пути в сетке


На сетке размером m x n находится робот. Робот изначально находится в верхнем левом углу (т.е. grid[0][0]). Робот пытается добраться до нижнего правого угла (т.е. grid[m - 1][n - 1]). Робот может двигаться только вниз или вправо в любой момент времени.
Учитывая два целых числа m и n, вернуть количество возможных уникальных путей, которые робот может пройти, чтобы достичь нижнего правого угла.

Тестовые случаи генерируются таким образом, что ответ будет меньше или равен 2 * 109.

Пример 1:



**Вход:** m = 3, n = 7
**Выход:** 28

Пример 2:

**Вход:** m = 3, n = 2
**Выход:** 3
**Пояснение:** Из верхнего левого угла существует три способа достичь нижнего правого угла:
1. Вправо -> Вниз -> Вниз
2. Вниз -> Вниз -> Вправо
3. Вниз -> Вправо -> Вниз

Ограничения:

1 <= m, n <= 100
Алгоритм 1
Данная задача связана с нахождением числа путей в сетке размером m x n. Робот может двигаться только вниз или вправо, поэтому чтобы достичь нижнего правого угла, он должен пройти m - 1 шагов вниз и n - 1 шагов вправо.

Мы можем рассмотреть эту задачу как составление последовательности из m - 1 шагов вниз и n - 1 шагов вправо. Нам нужно выбрать позиции для шагов вниз, а остальные позиции автоматически заполнятся шагами вправо. Таким образом, число путей равно количеству способов выбрать m - 1 позицию из общего числа позиций (m - 1 + n - 1).

Мы можем использовать формулу сочетаний для вычисления количества способов выбора m - 1 позиций из m - 1 + n - 1. Формула сочетаний записывается как:

C(N, k) = N! / (k! * (N - k)!)
где N - общее количество позиций, а k - количество выбранных позиций.

Таким образом, чтобы решить эту задачу, мы можем использовать формулу сочетаний и 
подставить соответствующие значения. Ответом будет количество возможных 
уникальных путей, которые робот может пройти.

Однако, обратите внимание, что вычисление факториалов больших чисел 
может быть очень ресурсоемким и затратным с точки зрения времени ЦП и памяти. 
Поэтому, чтобы избежать этой проблемы, мы можем использовать 
динамическое программирование и методы мемоизации.

Мы можем создать двумерный массив dp размером m x n, где dp[i][j] будет 
содержать количество уникальных путей, которые робот может пройти,
 чтобы достичь позиции (i, j). Изначально все значения dp[i][j] 
 установлены в 1, так как для достижения верхнего края и левого 
 края роботу не нужно делать ни одного шага.

Затем, мы можем перебирать все позиции (i, j) от (1, 1) до (m - 1, n - 1) и обновлять значения dp[i][j] суммой значений dp[i - 1][j] и dp[i][j - 1]. Это связано с тем, что робот может достичь позиции (i, j) только из позиции (i - 1, j) (сделав шаг вниз) или из позиции (i, j - 1) (сделав шаг вправо). Таким образом, количество уникальных путей до позиции (i, j) равно сумме количества путей до позиции (i - 1, j) и количества путей до позиции (i, j - 1).

В конце концов, dp[m - 1][n - 1] будет содержать количество уникальных путей, 
которые робот может пройти, чтобы достичь нижнего правого угла.

Таким образом, решение этой задачи без использования кода заключается 
в вычислении количества способов выбора m - 1 позиции из m - 1 + n - 1 с 
помощью формулы сочетаний. Однако, чтобы избежать проблем с вычислением 
факториалов больших чисел, мы можем использовать динамическое программирование, 
создав массив dp и обновляя его значения согласно правилам перехода. 
В конце концов, dp[m - 1][n - 1] будет содержать искомое количество уникальных путей.

*/

function uniquePaths(m, n) {
  // Инициализация таблицы dp
  const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));

  // Базовый случай: инициализация первой строки и первого столбца
  for (let i = 0; i < m; i++) {
    dp[i][0] = 1;
  }
  for (let j = 0; j < n; j++) {
    dp[0][j] = 1;
  }

  // Заполнение таблицы dp по формуле dp[i][j] = dp[i-1][j] + dp[i][j-1]
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
  }

  // Возвращаем результат из правого нижнего угла
  return dp[m - 1][n - 1];
}
